#include "stdafx.h"
#include <string>
#include <Winsock2.h>
#include <windows.h>
//#include "Nivdort.h"

#pragma comment(lib, "ws2_32.lib")

void MainTesting(void);

DWORD SENDKey = 0;
DWORD RECVKey = 0;
DWORD *DecryptionBytes = NULL;
DWORD *EncryptionBytes = NULL;

#define PATH_DUMPS "D:\\Malware_RE\\"
#define FILENAME_IP "D:\\Malware_RE\\c2_ips.txt"

typedef struct _C2_SERVER {
	UCHAR ip[16];
	USHORT port;
} C2_SERVER;


unsigned char GetIPListCommandEncrypted[] =
"\x5b\x8f\x75\x8b\x20\xf0\x90\xbd" // Encryption key: 0x8b758f5b
"\x48" // 0x13
"\x8d\x75" // 0x002
"\x98\xe2" // 0x0013 bytes to send
"\x2a\x9c\xdd\xb7\x86\x94\x67\xd9\xc9\xef\xe5\x79\xaa\x2e\x81\xd4\x58\xfd\x21"
// 13 00 00 00 00 00 00 00-07 00 00 00 03 b2 fa 8a d0 4f c6
//										  178.250.138.208 20422
"\xb9\xb9"; // 00 00 Null terminator


UCHAR GetIPListCommand[] =
"\x13"
"\x02\x00"
"\x13\x00"
"\x13\x00\x00\x00"
"\x00\x00\x00\x00"
"\x07\x00\x00\x00"
"\x03"
"\x90\x90\x90\x90" // Replace IP
"\x90\x90"         // Replace PORT
"\x00\x00";

UCHAR TestingCommand[] =
"\x13"
"\x02\x00"
"\x13\x00"
"\x13\x00\x00\x00"
"\xFF\x00\x00\x00"
"\x07\x00\x00\x00"
"\x03"
"\x90\x90\x90\x90" // Replace IP
"\x90\x90"         // Replace PORT
"\x00\x00";


/*
string build_blob();
void *alloc_rwx(size_t size) {
	void *mem = VirtualAlloc(0, size, 0x3000 , PAGE_EXECUTE_READWRITE);
	if (!mem) {
		cout << "Could not alloc RWX memory." << endl;
		return nullptr;
	}

	cout << "Allocated RwX memory at: " << mem << endl;
	return mem;
}

typedef DWORD(*_f)(int *, int, DWORD);

int _DecryptWithKey(DWORD key, size_t len) {
	string blob = build_blob();
	void *mem = alloc_rwx(blob.size());
	memcpy(mem, &blob[0], blob.size());

	_f F = (_f)mem;
	// TODO: Change the signature of the function pointer.
	F((int *)&buffer, len / 4, key);

	int i = 0;
	for (i = 0; i < len; i++) {
		printf("%c", buffer[i]);
	}
	getchar();
	return 0;
}

string build_blob() {
	string dispatch_table;
	// Dumped [0x00427500-0x00427707]
	string shellcode;
	shellcode.append("\x57", 1);                                 // 0x00000000: push     edi
	shellcode.append("\x56", 1);                                 // 0x00000001: push     esi
	shellcode.append("\x83\xec\x18", 3);                         // 0x00000002: sub      esp, 0x18
	shellcode.append("\x8b\x44\x24\x2c", 4);                     // 0x00000005: mov      eax, dword ptr [esp + 0x2c]
	shellcode.append("\x8b\x4c\x24\x28", 4);                     // 0x00000009: mov      ecx, dword ptr [esp + 0x28]
	shellcode.append("\x8b\x54\x24\x24", 4);                     // 0x0000000d: mov      edx, dword ptr [esp + 0x24]
	shellcode.append("\x89\x44\x24\x14", 4);                     // 0x00000011: mov      dword ptr [esp + 0x14], eax
	shellcode.append("\x89\x4c\x24\x10", 4);                     // 0x00000015: mov      dword ptr [esp + 0x10], ecx
	shellcode.append("\x89\x54\x24\x0c", 4);                     // 0x00000019: mov      dword ptr [esp + 0xc], edx
	shellcode.append("\x8b\x44\x24\x0c", 4);                     // 0x0000004a: mov      eax, dword ptr [esp + 0xc]
	shellcode.append("\x89\x44\x24\x08", 4);                     // 0x0000004e: mov      dword ptr [esp + 8], eax	
	shellcode.append("\x8b\x44\x24\x08", 4);                     // 0x00000064: mov      eax, dword ptr [esp + 8]
	shellcode.append("\x8b\x4c\x24\x10", 4);                     // 0x00000068: mov      ecx, dword ptr [esp + 0x10]
	shellcode.append("\x8d\x04\x88", 3);                         // 0x0000006c: lea      eax, dword ptr [eax + ecx*4]
	shellcode.append("\x89\x44\x24\x04", 4);                     // 0x0000006f: mov      dword ptr [esp + 4], eax
	shellcode.append("\x8b\x44\x24\x14", 4);                     // 0x0000008c: mov      eax, dword ptr [esp + 0x14]
	shellcode.append("\x89\x04\x24", 3);                         // 0x00000090: mov      dword ptr [esp], eax	
	shellcode.append("\x8b\x44\x24\x08", 4);                     // 0x000000a2: mov      eax, dword ptr [esp + 8]
	shellcode.append("\x3b\x44\x24\x04", 4);                     // 0x000000a6: cmp      eax, dword ptr [esp + 4]
	shellcode.append("\x74\x47", 2);							 // 0x000000aa: je       0x8c	
	shellcode.append("\x8b\x14\x24", 3);                         // 0x000000cf: mov      edx, dword ptr [esp]
	shellcode.append("\x8b\x74\x24\x08", 4);                     // 0x000000d2: mov      esi, dword ptr [esp + 8]
	shellcode.append("\x8b\x3e", 2);                             // 0x000000d6: mov      edi, dword ptr [esi]
	shellcode.append("\x31\xd7", 2);                             // 0x000000d8: xor      edi, edx
	shellcode.append("\x89\x3e", 2);                             // 0x000000da: mov      dword ptr [esi], edi
	shellcode.append("\x8b\x14\x24", 3);                         // 0x000000ee: mov      edx, dword ptr [esp]
	shellcode.append("\xc1\xc2\x1d", 3);                         // 0x000000f1: rol      edx, 0x1d
	shellcode.append("\x89\x14\x24", 3);                         // 0x000000f4: mov      dword ptr [esp], edx
	shellcode.append("\x0f\xb6\x44\x24\x01", 5);                 // 0x00000139: movzx    eax, byte ptr [esp + 1]
	shellcode.append("\x0f\xb6\x4c\x24\x02", 5);                 // 0x0000013e: movzx    ecx, byte ptr [esp + 2]
	shellcode.append("\x01\xc1", 2);                             // 0x00000143: add      ecx, eax
	shellcode.append("\x88\xca", 2);                             // 0x00000145: mov      dl, cl
	shellcode.append("\x88\x54\x24\x02", 4);                     // 0x00000147: mov      byte ptr [esp + 2], dl
	shellcode.append("\x0f\xb6\x44\x24\x02", 5);                 // 0x0000016d: movzx    eax, byte ptr [esp + 2]
	shellcode.append("\x0f\xb6\x4c\x24\x01", 5);                 // 0x00000172: movzx    ecx, byte ptr [esp + 1]
	shellcode.append("\x01\xc1", 2);                             // 0x00000177: add      ecx, eax
	shellcode.append("\x88\xca", 2);                             // 0x00000179: mov      dl, cl
	shellcode.append("\x88\x54\x24\x01", 4);                     // 0x0000017b: mov      byte ptr [esp + 1], dl
	shellcode.append("\x8b\x44\x24\x08", 4);                     // 0x000001ab: mov      eax, dword ptr [esp + 8]
	shellcode.append("\x83\xc0\x04", 3);                         // 0x000001af: add      eax, 4
	shellcode.append("\x89\x44\x24\x08", 4);                     // 0x000001b2: mov      dword ptr [esp + 8], eax
	shellcode.append("\xeb\xaf", 2);							 // 0x000001b6: jmp      0x3b
	shellcode.append("\x8b\x04\x24", 3);                         // 0x000001fe: mov      eax, dword ptr [esp]
	shellcode.append("\x83\xc4\x18", 3);                         // 0x00000201: add      esp, 0x18
	shellcode.append("\x5e", 1);                                 // 0x00000204: pop      esi
	shellcode.append("\x5f", 1);                                 // 0x00000205: pop      edi
	shellcode.append("\xc3", 1);                                 // 0x00000206: ret      

	return shellcode + dispatch_table;
}
*/


DWORD CalculateDecryptionKey(DWORD key) {
	/*
	def CalculateRecvDecryptionKey(key):
	key = ROL(key,0x06,32)
	key[1] = key[2] + key[1]
	key[2] = key[2] + key[1]
	*/
	__asm {
		mov eax, key;
		rol eax, 0x6;
		push ebx;
		push ecx;
		mov ebx, eax;
		shr ebx, 0x08;
		and ebx, 0xFF;
		mov ecx, eax;
		shr ecx, 0x10;
		and ecx, 0xFF;
		add bl, cl;
		add cl, bl;
		shl ecx, 0x10;
		shl ebx, 0x08;
		add ecx, ebx;
		and eax, 0xFF0000FF;
		add eax, ecx;
		pop ecx;
		pop ebx;
	}
	return;
}

DWORD SendRecvEncryptionDecryptionStream(DWORD key) {
	__asm {
		mov eax, key;
		rol eax, 0x6;
		mov key, eax;
		push ebx;
		movzx eax, byte ptr[key + 1];
		movzx ebx, byte ptr[key + 2];
		add al, bl;
		mov byte ptr[key + 1], al;
		movzx eax, byte ptr[key + 1];
		movzx ebx, byte ptr[key + 2];
		add al, bl;
		mov byte ptr[key + 2], al;
		pop ebx;
		mov eax, key;
	}
	return;
}

unsigned char* GenerateDecryptionBlock(DWORD key, size_t sizeInDwords) {
	DWORD *block = (DWORD *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeInDwords * 4);
	int i = 0;
	for (i = 0; i < sizeInDwords; i++) {
		block[i] = key;
		key = CalculateDecryptionKey(key);
	}
	return (unsigned char *)&block[0];
}

DWORD vaporStreamCipher(DWORD key) {
	__asm {
		mov eax, key;
		rol eax, 0x1d;
		mov key, eax;
		push ebx;	
		movzx eax, byte ptr[key + 1];
		movzx ebx, byte ptr[key + 2];
		add al, bl;
		mov byte ptr [key + 2], al;
		movzx eax, byte ptr[key + 1];
		movzx ebx, byte ptr[key + 2];
		add al, bl;
		mov byte ptr[key + 1], al;
		pop ebx;
		mov eax, key;
	}
	return;
}


DWORD* GlobalTableDecryption(void) {

	DWORD Seed = 0xc940257f;
	DWORD tableSize = 0x49EC;
	DWORD *table = (DWORD *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, tableSize);
	int i = 0;
	DWORD key = Seed;
	for (i = 0; i < tableSize/4; i++) {
		printf("%08x ", key);
		table[i] = key;
		key = vaporStreamCipher(key);		
	}
	return table;
}

// The received data, even if deciphered with our EncryptionRecvKey, is still ciphered
// The data has at its offset +4 a DWORD key which has to be xored with 'MAPS' in order to get
// the real key
// From this point, the key is used and XORed with data offset 0, to get the size of the payload
// After that, it must be chcked that the size matches the length of the rest of the data.
// THen the data is xored with the next streamCipher algorithm and the Key.
DWORD RecvStreamCipher(DWORD key) {
	__asm {
		mov eax, key;
		rol eax, 0x1F;
		mov key, eax;
		push ebx;
		movzx eax, byte ptr[key];
		movzx ebx, byte ptr[key + 1];
		add al, bl;
		mov byte ptr[key + 1], al;
		movzx eax, byte ptr[key];
		movzx ebx, byte ptr[key + 1];
		add al, bl;
		mov byte ptr[key], al;
		pop ebx;
		mov eax, key;
	}
	return;
}



void Crash(char *msg)
{
	perror(msg);
	printf("Code: %d\n", errno);
	exit(-1);
}


int SockInitCreate()
{
	WSADATA wsaData;
	WORD wVersionRequested;

	wVersionRequested = MAKEWORD(2, 2);
	if (WSAStartup(wVersionRequested, &wsaData))
		Crash("Winsock startup error");
	return WSASocketA(AF_INET, 1, 0, NULL, NULL, NULL);
}

bool NonBlockConnect(SOCKET csock, char *host, int port, int timeout)
{
	TIMEVAL Timeout;
	Timeout.tv_sec = timeout;
	Timeout.tv_usec = 0;
	struct sockaddr_in address; 

	address.sin_addr.s_addr = inet_addr(host); 
	address.sin_port = htons(port); 
	address.sin_family = AF_INET;

	//set the socket in non-blocking
	unsigned long iMode = 1;
	int iResult = ioctlsocket(csock, FIONBIO, &iMode);
	if (iResult != NO_ERROR)
	{
		printf("ioctlsocket failed with error: %ld\n", iResult);
	}

	if (connect(csock, (struct sockaddr *)&address, sizeof(address)) == false)
	{
		return false;
	}

	// restart the socket mode
	iMode = 0;
	iResult = ioctlsocket(csock, FIONBIO, &iMode);
	if (iResult != NO_ERROR)
	{
		printf("ioctlsocket failed with error: %ld\n", iResult);
	}

	fd_set Write, Err;
	FD_ZERO(&Write);
	FD_ZERO(&Err);
	FD_SET(csock, &Write);
	FD_SET(csock, &Err);

	// check if the socket is ready
	select(0, NULL, &Write, &Err, &Timeout);
	if (FD_ISSET(csock, &Write))
	{
		return true;
	}

	return false;
}

/*
int SockConnect(int csock, char *ip, short port)
{	
	struct sockaddr_in server;
	server.sin_family = AF_INET;
	server.sin_port = htons(port);
	server.sin_addr.s_addr = inet_addr(ip);
	return connect(csock, (struct sockaddr *)&server, sizeof(server));
}
*/


void GetEncryptionBytes(PVOID buffer, UINT len, BOOL renew) {
	static DWORD key = SENDKey;
	static UINT used = 0;
	static UINT generated = 0;
	int i = 0;
	UINT available = generated - used;
	char *ptr;

	if (renew) {
		key = SENDKey;
		used = 0;
		generated = 0;
		available = 0;
		if (EncryptionBytes != NULL) HeapFree(GetProcessHeap(), 0, EncryptionBytes);
		EncryptionBytes = NULL;
	}

	if (EncryptionBytes == NULL)
	{
		EncryptionBytes = (DWORD *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len + 1);
		for (i = 0; i < (len / 4) + 1; i++) {
			//printf("%08x ", key);
			EncryptionBytes[i] = key;
			key = SendRecvEncryptionDecryptionStream(key);
			generated += 4;
		}
		memcpy(buffer, EncryptionBytes, len);
		used = used + len;
	}
	else {
		if (len <= available) {
			ptr = ((char *)EncryptionBytes + used);
			memcpy(buffer, ptr, len);
			used = used + len;
		}
		else {
			ptr = ((char *)EncryptionBytes + used);
			memcpy(buffer, ptr, available);
			generated = 0;
			HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, EncryptionBytes, len + 1);
			for (i = 0; i < (len / 4) + 1; i++) {
				//printf("%08x ", key);
				EncryptionBytes[i] = key;
				key = SendRecvEncryptionDecryptionStream(key);
				generated += 4;
			}
			memcpy((char *)buffer + available, EncryptionBytes, len - available);
			used = len - available;
		}
	}

}



void GetDecryptionBytes(PVOID buffer, UINT len, BOOL renew) {
	static DWORD key = RECVKey;
	static UINT used = 0;
	static UINT generated = 0;
	int i = 0;
	UINT available = generated - used;
	char *ptr;

	if (renew) {
		key = RECVKey;
		used = 0;
		generated = 0;
		available = 0;
		if (DecryptionBytes != NULL) HeapFree(GetProcessHeap(), 0, DecryptionBytes);
		DecryptionBytes = NULL;
	}

	if (DecryptionBytes == NULL)
	{
		DecryptionBytes = (DWORD *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len + 1);
		for (i = 0; i < (len / 4) + 1; i++) {
			//printf("%08x ", key);
			DecryptionBytes[i] = key;
			key = SendRecvEncryptionDecryptionStream(key);
			generated += 4;
		}	
		memcpy(buffer, DecryptionBytes, len);
		used = used + len;
	} else {
		if (len <= available) {
			ptr = ((char *)DecryptionBytes + used);
			memcpy(buffer, ptr, len);
			used = used + len;
		} else {
			ptr = ((char *)DecryptionBytes + used);
			memcpy(buffer, ptr, available);
			generated = 0;
			HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, DecryptionBytes, len + 1);
			for (i = 0; i < (len / 4) + 1; i++) {
				//printf("%08x ", key);
				DecryptionBytes[i] = key;
				key = SendRecvEncryptionDecryptionStream(key);
				generated += 4;
			}
			memcpy((char *)buffer + available, DecryptionBytes, len - available);
			used = len - available;
		}
	}
	
}



void ParseResult_GetIPs(UCHAR *buffer) {
	UCHAR *ptr = buffer;
	ptr = ptr + 8;
	USHORT NumOfObjects = *(USHORT *)ptr;
	printf("NumOfObjects: %04x\n", NumOfObjects);
	UINT i = 0;
	UINT index;
	DWORD ip_dword;
	WORD port;
	struct in_addr addr;
	ptr += 2; //SKIP the NumOfObjects

	FILE *fp = fopen(FILENAME_IP, "at");
	while (i < NumOfObjects) {
		index = i * 3;
		index = index * 2;
		ip_dword = (ptr[index + 3] << 24) + (ptr[index + 2] << 16) + (ptr[index + 1] << 8) + ptr[index + 0];
		//printf("IP DWORD: %08x\n", ip_dword);
		port = (ptr[index + 4] << 8) + ptr[index + 5];
		i++;
		addr.S_un.S_addr = ip_dword;
		printf("IP: %s  PORT: %d\n", inet_ntoa(addr), port);
		//printf("%s : %d\n", inet_ntoa(addr), port);
		fprintf(fp, "%s : %d\n", inet_ntoa(addr), port);
	}
	fclose(fp);
}

void DumpBinaryBuffer(UCHAR *buffer, UINT buffSize, char *ip) {
	char filename[256] = { 0 };
	sprintf(filename, "%s\\%s.bin", PATH_DUMPS, ip);
	FILE *fp = fopen(filename, "wb");
	fwrite(buffer, buffSize, 1, fp);
	fclose(fp);
}

UINT prepareCommand0x13(UCHAR *buffer, char *ip, USHORT port) {
	// This function performs the encryption of the 0x13 command 
	// for the specified IP/PORT pair
	UCHAR *_local_encryptionBytes = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x2000);
	GetEncryptionBytes(_local_encryptionBytes, 26, TRUE);

	UCHAR *ptr = GetIPListCommand;
	ptr += 18;
	*(DWORD *)ptr = inet_addr(ip);
	ptr += 4;
	*(WORD *)ptr = htons(port);
	ptr = GetIPListCommand;
	int i = 0;
	
	for (i = 0; i < 26; i++) {
		buffer[i] =  ptr[i] ^ _local_encryptionBytes[i];
	}

	HeapFree(GetProcessHeap(), 0, _local_encryptionBytes);
	return 26;
}

UINT prepareTestingCommand(UCHAR *buffer, char *ip, USHORT port) {
	// This function performs the encryption of the 0x13 command 
	// for the specified IP/PORT pair
	UCHAR *_local_encryptionBytes = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x2000);
	GetEncryptionBytes(_local_encryptionBytes, 26, TRUE);

	UCHAR *ptr = TestingCommand;
	ptr += 18;
	*(DWORD *)ptr = inet_addr(ip);
	ptr += 4;
	*(WORD *)ptr = htons(port);
	ptr = TestingCommand;
	int i = 0;

	for (i = 0; i < 26; i++) {
		buffer[i] = ptr[i] ^ _local_encryptionBytes[i];
	}

	HeapFree(GetProcessHeap(), 0, _local_encryptionBytes);
	return 26;
}

void connectToC2(DWORD key, UCHAR *ip, USHORT port) {

	TIMEVAL Timeout;
	Timeout.tv_sec = 10;
	Timeout.tv_usec = 0;
	USHORT MAX_RECV_SIZE = 0x5000;

	USHORT bytesRecv = 0;
	UCHAR *decryptionBytes = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x2000);
	UCHAR *RecvBuffer = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_RECV_SIZE);
	UCHAR *Buffer = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_RECV_SIZE);
	UINT BytesToRecv = 0;

	SENDKey = key;
	RECVKey = CalculateDecryptionKey(key);
	UCHAR *commandBuff = (UCHAR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1000);
	UINT commandLength = 0;
	
	SOCKET s = SockInitCreate();
	
	fd_set Read = {0};
	FD_SET(s, &Read);


	printf("Trying to connect to: %s:%d\n", ip, port);
	if (NonBlockConnect(s, (char *)ip, port, 3)) {
		// Send hardcoded encrptionkey
		send(s, "\x5b\x8f\x75\x8b\x20\xf0\x90\xbd", 8, 0);

		commandLength = prepareCommand0x13(commandBuff, (char *)ip, port);
		//commandLength = prepareTestingCommand(commandBuff, (char *)ip, port);
		send(s, (char *)commandBuff, commandLength, 0);
		printf("Command 0x13 was sent!\n");

		// check if the socket is ready
		select(0, &Read, NULL, NULL, &Timeout);
		if (FD_ISSET(s, &Read))
		{
			bytesRecv = recv(s, (char *)RecvBuffer, 2, 0);
			if (bytesRecv != SOCKET_ERROR) {
				GetDecryptionBytes(decryptionBytes, 0x2000, TRUE);
				printf("Bytes received: %08x\n", bytesRecv);
				BytesToRecv = ((decryptionBytes[1] ^ RecvBuffer[1]) << 8) + decryptionBytes[0] ^ RecvBuffer[0];
				printf("Size to recv: %04x\n", BytesToRecv);
				bytesRecv = 0;
				while (bytesRecv < BytesToRecv) {
					bytesRecv += recv(s, (char *)RecvBuffer + bytesRecv, BytesToRecv, 0);
					select(0, &Read, NULL, NULL, &Timeout);
					if (!FD_ISSET(s, &Read))
						break;
				}
				int i = 0;
				for (i = 0; i < bytesRecv; i++) {
					//printf("%02x ", RecvBuffer[i] ^ decryptionBytes[i+2]);
					Buffer[i] = RecvBuffer[i] ^ decryptionBytes[i + 2];
				}
				ParseResult_GetIPs(Buffer);
				DumpBinaryBuffer(Buffer, BytesToRecv, (char *)ip);
			}
			else {
				printf("Seems HOST: %s:%d is down\n", ip, port);
			}
		}
		else {
			printf("Read Timeout!\n");
		}
	}
	
	HeapFree(GetProcessHeap(), 0, commandBuff);
	HeapFree(GetProcessHeap(), 0, RecvBuffer);
	HeapFree(GetProcessHeap(), 0, Buffer);
	closesocket(s);
}




void StartCommunication(void) {
	C2_SERVER C2_List[]{
		{ "103.59.205.40", 22972 },
		{ "37.142.247.223", 22969 },
		{ "89.138.217.21", 21212 },
		{ "79.182.80.180", 33634 },
		{ "81.134.1.9", 45279 },
		{ "176.37.2.43", 44303 },
		{ "117.218.187.28", 42065 },
		{ "108.189.140.68", 41209 },
		{ "50.250.231.206", 50776 },
		{ "86.185.146.126", 30982 },
		{ "5.89.138.37", 35833 },
		{ "72.132.76.8", 35779 },
		{ "2.50.156.78", 35711 },
		{ "87.69.238.184", 44724 },
		{ "189.244.51.96", 28122 },
		{ "89.120.101.64", 30714 },
		{ "93.173.140.196", 29863 },
		{ "61.246.2.217", 25840 },
		{ "88.148.36.4", 25752 },
		{ "83.110.203.141", 26734 },
		{ "213.37.5.79", 49380 },
		{ "84.94.45.89", 49727 },
		{ "46.25.134.22", 36034 },
		{ "86.35.197.245", 25978 },
		{ "188.2.10.6", 44843 },
		{ "200.123.152.97", 27682 },
		{ "94.205.160.53", 36355 },
		{ "86.98.69.106", 41590 },
		{ "90.75.215.140", 49291 },
		{ "70.196.135.80", 41500 },
		{ "122.160.123.173", 36805 },
		{ "188.78.118.52", 23245 },
		{ "78.121.130.191", 23699 },
		{ "197.16.160.211", 34550 },
		{ "87.71.64.127", 30018 },
		{ "98.70.222.153", 20922 },
		{ "217.165.4.137", 26502 },
		{ "89.45.163.63", 50096 },
		{ "188.86.131.45", 28990 },
		{ "2.50.142.171", 22437 },
		{ "109.102.79.27", 36272 },
		{ "93.156.144.177", 30459 },
		{ "109.99.142.6", 20155 },
		{ "108.35.150.243", 24830 },
		{ "74.65.64.25", 22739 },
		{ "176.36.177.19", 25630 },
		{ "94.201.114.138", 44254 },
		{ "89.130.20.12", 46689 },
		{ "87.67.245.8", 33631 },
		{ "2.50.162.11", 35196 },
		{ "186.120.35.137", 43621 },
		{ "79.118.132.213", 22773 },
		{ "81.35.222.124", 31810 },
		{ "2.50.137.65", 27577 },
		{ "84.108.128.25", 27132 },
		{ "94.67.200.147", 41925 },
		{ "86.127.17.15", 45688 },
		{ "188.25.59.224", 27426 },
		{ "185.95.73.246", 27577 },
		{ "178.250.138.208", 20422 },
		{ "75.85.211.234", 31064 },
		{ "89.137.252.28", 48576 },
		{ "85.64.86.41", 51481 }
	};
	
	int i = 0;
	
	for (i = 0; i < sizeof(C2_List); i++) {	
		DWORD key = 0x8b758f5b;		
		connectToC2(key, C2_List[i].ip, C2_List[i].port);
	}
	
	//DWORD key = 0x8b758f5b;
	//connectToC2(key, (UCHAR *)"117.218.187.28", 42065);
	//connectToC2(key, (UCHAR *)"72.132.76.8", 35779);
	
}


int main(int argc, char **argv) {

	
	StartCommunication();
	//MainTesting();
	getchar();
}